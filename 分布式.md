# CAP

## 什么是 CAP 定理

- Consistency 一致性

  访问分布式系统中的任意节点，能返回一致结果。

- Availability 可用性

  分布式系统总能向客户端返回响应。

- Partition tolerance 分区容忍

  当分布式系统节点间出现消息丢失或者延迟，仍然允许系统继续运行。

CAP 定理：最多三选二，无法兼得，通常在 CP 和 AP 之间选择，即 C 与 A 无法兼顾。

## CP 还是 AP

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220617223503577.png" alt="image-20220617223503577" style="zoom:50%;" />

左边是 CP 情况，这时 客户端 向 节点1 写入数据，想要保证各个节点数据一致必须要实现各个节点的数据同步，如果此时出现网络分区则此时其他节点是不能访问的，因此不能保证可用性。

右边是 AP 情况，如果出现网络分区，各个节点读取的数据可能不一致，但是都能读到，保证了可用性。

## 一致性级别

- 强一致性

  系统写入什么，读出来就是什么，实现起来对性能影响很大。

  例如火车站售票，有就是有，没有就是没有，不能出现不一致的情况，典型算法有：Paxos、Raft、ZAB

- 弱一致性

  系统写入成功不保证立刻可以读到值，也不承诺什么时候能达到数据一致，可以细分为：

  - 会话一致性，同一个客户端会话可以保证一致，其他会话不能保证。
  - 用户一致性，同一个用户可以保证一致，其他用户不能保证。

  例如网购时，商品详情页发现库存量还有，下单时才提示库存不足，数据不一致。

- 最终一致性

  弱一致的特例，保证一定时间内达到一致状态。

  例如转账，完成会有提示，多长时间内能到账，最终是一致的。

  算法：Gossip

# Paxos 算法（强一致性算法）

问题：

![image-20220617225131282](C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220617225131282.png)

集群中有 N 个节点，一个节点写入后要求同步到剩余 N-1 个节点再向客户端返回 OK，最保险，但是如果一个节点同步失败，会造成整个集群不可用，如果提高性能？

这里采取 "多数派" 算法（不保证读一致性），即设置 2K + 1（奇数）个节点，只要其中过半的节点同步成功，则可以向客户端发送 OK，但是会导致一个 "顺序性" 问题：

![image-20220617225933743](C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220617225933743.png)

## Paxos 角色划分和阶段

- 角色划分：

  集群中的每个节点都可以充当

  - Proposer：负责生成提案

    允许多个 Proposer，但是可能导致 活锁

    > 活锁：
    >
    > 活锁是指正在执行的线程或进程没有发生阻塞，但由于某些条件没有满足，导致反复重试-失败-重试-失败的过程。与死锁最大的区别在于：活锁状态的线程或进程是一直处于运行状态的，在失败中不断重试，重试中不断失败，一直处于所谓的“活”态，不会停止。而发生死锁的线程则是相互等待，双方之间的状态是不会发生改变的，处于所谓的“死”态。
    >
    > 比如同时往某处位置写入数据，但同时只能允许一条线程写入数据，所以在写入之前会检测是否有其他线程存在，如果有则放弃本次写入，过一段时间之后再重试。而此时正好有两条线程同时写入又相互检测到了对方，然后都放弃了写入，而重试的时间间隔都为1s，结果1s后这两条线程又碰头了，然后来回重复这个过程.....
    >
    > 当然，在程序中除开上述这种多线程之间协调导致的活锁情况外，单线程也会导致活锁产生，比如远程RPC调用中就经常出现，A调用B的RPC接口，需要B的数据返回，结果B所在的机器网络出问题了，A就不断的重试，最终导致反复调用，不断失败。

  - Acceptor：负责批准提案

    应该有多个，如果只有一个会存在单点问题

  - Learner：负责获取提案

    Acceptor 批准后，将提案发送给所有 Learner

执行一个修改，不是上来就执行：

- 准备阶段：由多数派 Acceptor 批准通过
- 接受阶段：要执行的修改操作广播给 Acceptor，此时仍然多数派通过，此次修改才能生效，返回响应给客户端。

## Basic Paxos

前置知识：

- Acceptor 和 Proposer 都会维护一个全局变量：minN，最小提案号。
- 接受的提案号和接受的值会形成一个键值对，由于提案号具有 ID 性质，因此可以根据提案号查询对应的值。

算法流程：

![image-20220617233445041](C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220617233445041.png)

Proposer 生产出提案号然后广播给 Acceptor，顺便更新 Acceptor 的 minN，之后根据多数派原则响应给 Proposer，如果应答过半就用最大的 accpetNo 的 acceptValue 替换 value，Proposer 再广播提案号和值，同步 Acceptor 的 acceptN 和 value（n >= minN），根据多数派原则，过半则成功，否则失败。

# Raft 算法（强一致性算法）

比 Paxos 更容易理解

Raft 算法分为 3 部分：

- Leader 选举

  - 只有一个 Server 能作为 Leader
  - 一旦此 Server 崩溃，选举新 Leader

- 执行操作

  以日志复制为例：

  - 由 Leader 执行自己的日志记录
  - 将日志复制给其他 Server，会覆盖不一致的部分
  - 多数派记录日志成功，Leader 才能执行命令，向 客户端返回结果

- 确保安全

  - 确保日志记录的一致性
  - 拥有最新日志的 Server 才能成为 Leader

## Leader 选举

可视化网站：https://raft.github.io/raftscope/index.html

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619143614748.png" alt="image-20220619143614748" style="zoom:50%;" />

当 S1 第一期结束（第一个结束），S1 决定当选 Leader

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619143757446.png" alt="image-20220619143757446" style="zoom:50%;" />

S1 当选后，需要不断向其他 Server 发送信号，证明自己还存活，同时其他 Server 会重置自己的 timeout（超时时间）

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619143913877.png" alt="image-20220619143913877" style="zoom:50%;" />

如果 Leader 挂了，其他服务器无法接受 Leader 信号，得知 Leader 挂了，其他服务器会再选举一个 Leader 来。

如果选民 timeout 属性超时，转换角色为候选者，将 任期 + 1，发送推选自己请求。

## 执行操作

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619145705675.png" alt="image-20220619145705675" style="zoom:50%;" />

此时 S5 当选 Leader，注意右边的框是虚线框，这表示S5仅仅是记录日志，没有执行对应的操作。

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619145821355.png" alt="image-20220619145821355" style="zoom:50%;" />

S5 发送的操作发到了选民处，选民哪里也只是记录了日志，并将结果发送给 S5，这里遵循多数派机制，一半以上的选民都收到了这条命令记录了日志

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619145938394.png" alt="image-20220619145938394" style="zoom:50%;" />

此时 S5（leader）就知道这个操作可以执行了，于是执行了这条操作，将执行这条操作的指令下发给选民

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619150034024.png" alt="image-20220619150034024" style="zoom:50%;" />

选民完成后，将结果返回给 Leader

**如果其中有选民挂掉之后恢复，如何同步？**

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619150405913.png" alt="image-20220619150405913" style="zoom:50%;" />

当 S3 挂掉，Leader 发送了几条命令全部缺失，之后如果 S3 恢复

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619150450014.png" alt="image-20220619150450014" style="zoom:50%;" />

Leader 会确保S3 将之前丢失的操作补回。

## 确保安全

**Leader 的完整性**：

1. Leader 被认为拥有最完整的日志
2. 一旦 Leader 完成了某条命令提交，未来的 Leader 必须存有该命令提交信息
3. 日志按照`<最新 Term, 最新 Index>` 排序，投票时，会将候选者的 `<Term, Index>` 随投票请求发送，如果候选者的日志没有选民的新，选民投否决票。

如下例：

![image-20220619151517463](C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619151517463.png)

如果 S2 向 S1 发送投票请求，S1 会投否决票，因为 S2 索引小于 S1 索引

如果 S5 发送投票请求也会被否决，因为 S5 任期只有2，其他选民任期是3

**选民日志的一致性**：

1. 以 Leader 为准，对选民的日志进行补充或者覆盖
2. Leader 向其他选民同步信息时，请求发送时会携带最新的`<Term, Index, Command>` 以及上一个 `<Term, Index>`
3. 如果选民发现上一个 `<Term, Index>` 能对应则成功，否则失败，继续携带更早的信息进行比对。

![image-20220619152217953](C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619152217953.png)

这里选民确实了 2 和 3 两条信息，Leader 同步会将 3 发送给选民，选民发现 Leader 发送的 3 的上一个 `<Term, Index>` 无法对应，需要 Leader 发送更早的信息，这样才能同步成功。

# Gossip 协议（最终一致性）

基于传染病方法的点对点的传播过程。

可以快速将信息散播给集群中每个成员，速度为 `logf(N)`，f 表示随机传播的成员数，N 表示总成员数。

可视化网站：https://flopezluis.github.io/gossip-simulator/

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619153108067.png" alt="image-20220619153108067" style="zoom:50%;" />

第一次传播，0号病人传染了其他 4 个人

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619153200070.png" alt="image-20220619153200070" style="zoom:50%;" />

<img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619153219516.png" alt="image-20220619153219516" style="zoom:50%;" />

我总共尝试了 4 次，才将全部人感染，这里的 4 是大于 2.66 的，因为可能有的病人会被重复感染。

**优点**：

- 扩展性高，传播次数不会受集群成员增长而增长过快。

  因为 log 函数的特性就是这样

  <img src="C:\Users\HASEE\Desktop\读书笔记\分布式.assets\image-20220619153715282.png" alt="image-20220619153715282" style="zoom:25%;" />

- 容错性好，即使某些节点发生了故障无法通信，不影响最终一致性。

  例如 A 和 B 之间发生故障无法通信，只要 A 与其他能连通 B 的节点通信，就可以让 B 接收到信息。

- Robust，健壮，集群中的节点对等，即使一些节点挂了，一些节点新添加进来，不会影响其他节点信息传播。